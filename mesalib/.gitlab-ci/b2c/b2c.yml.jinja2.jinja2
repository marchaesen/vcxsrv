version: 1

# Rules to match for a machine to qualify
target:
  id: '{{ ci_runner_description }}'

timeouts:

  first_console_activity:  # This limits the time it can take to receive the first console log
    minutes: {{ timeout_first_console_activity_minutes | default(0, true) }}
    seconds: {{ timeout_first_console_activity_seconds | default(0, true) }}
    retries: {{ timeout_first_console_activity_retries }}

  console_activity:        # Reset every time we receive a message from the logs
    minutes: {{ timeout_console_activity_minutes | default(0, true) }}
    seconds: {{ timeout_console_activity_seconds | default(0, true) }}
    retries: {{ timeout_console_activity_retries }}

  boot_cycle:
    minutes: {{ timeout_boot_minutes | default(0, true) }}
    seconds: {{ timeout_boot_seconds | default(0, true) }}
    retries: {{ timeout_boot_retries }}

  overall:                 # Maximum time the job can take, not overrideable by the "continue" deployment
    minutes: {{ timeout_overall_minutes | default(0, true) }}
    seconds: {{ timeout_overall_seconds | default(0, true) }}
    retries: 0
    # no retries possible here

  watchdogs:
    boot:
      minutes: {{ timeout_boot_wd_minutes | default(0, true) }}
      seconds: {{ timeout_boot_wd_seconds | default(0, true) }}
      retries: {{ timeout_boot_wd_retries | default(0, true) }}

console_patterns:
    session_end:
        regex: >-
          {{ session_end_regex }}
{% if session_reboot_regex %}
    session_reboot:
        regex: >-
          {{ session_reboot_regex }}
{% endif %}
    job_success:
        regex: >-
          {{ job_success_regex }}
{% if job_warn_regex %}
    job_warn:
        regex: >-
          {{ job_warn_regex }}
{% endif %}

{% if boot_wd_start_regex and boot_wd_stop_regex %}
    watchdogs:
        boot:
            start:
              regex: >-
                {{ boot_wd_start_regex }}
            reset:
              regex: >-
                {{ boot_wd_reset_regex | default(boot_wd_start_regex, true) }}
            stop:
              regex: >-
                {{ boot_wd_stop_regex }}
{% endif %}

# Environment to deploy
deployment:
  # Initial boot
  start:
    storage:
{% if imagestore_platform %}
        imagestore:
          public:
            # List of images that should be pulled into the image store ahead of execution
            images:
              mars:
                name: "{{ machine_registration_image }}"
                platform: "{{ imagestore_platform }}"
                tls_verify: false
                {% set machine_registration_image="{% raw %}{{ job.imagestore.public.mars.image_id }}{% endraw %}" %}
              telegraf:
                name: "{{ telegraf_image }}"
                platform: "{{ imagestore_platform }}"
                tls_verify: false
                {% set telegraf_image="{% raw %}{{ job.imagestore.public.telegraf.image_id }}{% endraw %}" %}
              image_under_test:
                name: "{{ image_under_test }}"
                platform: "{{ imagestore_platform }}"
                tls_verify: false
                {% set image_under_test="{% raw %}{{ job.imagestore.public.image_under_test.image_id }}{% endraw %}" %}
        nbd:
          storage:
            max_connections: 5
            size: 10G
{% endif %}

        http:
          - path: "/install.tar.zst"
            url: "{{ install_tarball_url }}"
          - path: "/b2c-extra-args"
            data: >
              b2c.pipefail b2c.poweroff_delay={{ poweroff_delay }}
              b2c.minio="gateway,{{ '{{' }} minio_url }},{{ '{{' }} job_bucket_access_key }},{{ '{{' }} job_bucket_secret_key }}"
              b2c.volume="{{ '{{' }} job_bucket }}-results,mirror=gateway/{{ '{{' }} job_bucket }},pull_on=pipeline_start,push_on=changes,overwrite{% for excl in job_volume_exclusions %},exclude={{ excl }}{% endfor %},remove,expiration=pipeline_end,preserve"
              {% for volume in volumes %}
              b2c.volume={{ volume }}
              {% endfor %}
              b2c.run_service="--privileged --tls-verify=false --pid=host {{ telegraf_image }}" b2c.hostname=dut-{{ '{{' }} machine.full_name }}
              b2c.run="-ti --tls-verify=false {{ machine_registration_image }} {% if mars_setup_tags %}setup --tags {{ mars_setup_tags }}{% else %}check{% endif %}"
              b2c.run="-v {{ '{{' }} job_bucket }}-results:{{ working_dir }} -w {{ working_dir }} {% for mount_volume in mount_volumes %} -v {{ mount_volume }}{% endfor %} --tls-verify=false --entrypoint bash {{image_under_test}} -euc 'curl -q {{ '{{' }} job.http.url }}/install.tar.zst | tar --zstd -x; {{ container_cmd }}'"
    kernel:
{% if kernel_url %}
      url: '{{ kernel_url }}'
{% endif %}

      # NOTE: b2c.cache_device should not be here, but this works around
      # a limitation of b2c which will be removed in the next release
      cmdline: >
        SALAD.machine_id={{ '{{' }} machine_id }}
        console={{ '{{' }} local_tty_device }},115200
        b2c.ntp_peer=10.42.0.1
        b2c.extra_args_url={{ '{{' }} job.http.url }}/b2c-extra-args
        {% if imagestore_platform is defined %}
        {{ '{{' }} imagestore.mount("public").nfs.to_b2c_filesystem("publicimgstore") }}
        b2c.storage="additionalimagestores=publicimgstore"
        b2c.nbd=/dev/nbd0,host=ci-gateway,port={% raw %}{{ '{{' }} job.nbd.storage.tcp_port }}{% endraw %},connections=5
        b2c.cache_device=/dev/nbd0
        {% else %}
        b2c.cache_device=auto
        {% endif %}
        {% if kernel_cmdline_extras is defined %}
        {{ kernel_cmdline_extras }}
        {% endif %}

{% if initramfs_url or firmware_url %}
    initramfs:
{% if firmware_url %}
      - url: '{{ firmware_url }}'
{% endif %}
{% if initramfs_url %}
      - url: '{{ initramfs_url }}'
{% endif %}
{% endif %}

{% if dtb_url %}
    dtb:
      url: '{{ dtb_url }}'
{% if dtb_match %}
      format:
        archive:
          match: "{{ dtb_match }}"
{% endif %}
{% endif %}
